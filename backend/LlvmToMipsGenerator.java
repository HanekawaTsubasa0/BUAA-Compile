package backend;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * A minimal LLVM IR (subset) to MIPS translator.
 * It assumes the IR generated by {@link LlvmIRGenerator} (no phi).
 * Stack layout:
 *   fp -> old sp
 *   fp-4 : saved ra
 *   fp-8 : saved fp
 *   fp-12 ... : locals/temps (growing to lower addresses)
 */
public class LlvmToMipsGenerator {
    /* ------------ data models ------------ */
    private static class DataItem {
        String name;
        boolean isString;
        List<Integer> ints;
        String str; // decoded ascii
    }

    private static class Func {
        String name; // without '@'
        String retType;
        List<String> params = new ArrayList<>();
        List<Integer> paramWidths = new ArrayList<>();
        List<String> body = new ArrayList<>();
        Map<String, Integer> allocaOffset = new HashMap<>(); // %x -> offset from fp (positive), address = fp - off
        Map<String, Integer> valOffset = new HashMap<>();     // SSA value slots
        Map<String, Integer> valWidth = new HashMap<>();      // byte width for SSA values/pointers
        int frameSize;
    }

    /* ------------ public API ------------ */
    public String generateFromFile(String path) throws IOException {
        List<String> lines = Files.readAllLines(Paths.get(path));
        ParseResult pr = parse(lines);
        pr.funcs.forEach(this::planFrame);

        StringBuilder sb = new StringBuilder();
        emitData(pr.dataItems, sb);
        emitText(pr.funcs, sb);
        return sb.toString();
    }

    // New: generate directly from structured IR module (no file parsing)
    public String generateFromModule(backend.ir.IrModule module) {
        ParseResult pr = new ParseResult();
        // data segment: globals and string literals as already formatted
        for (String g : module.getGlobalDefs()) {
            pr.dataItems.add(parseData(g));
        }
        for (String s : module.getStringDefs()) {
            pr.dataItems.add(parseData(s));
        }

        for (backend.ir.IrFunction fn : module.getFunctions()) {
            Func f = new Func();
            parseFuncHeader(fn.getHeader(), f);
            for (backend.ir.IrBasicBlock bb : fn.getBlocks()) {
                f.body.add(bb.getLabel() + ":");
                for (backend.ir.IrInstruction ins : bb.getInstructions()) {
                    f.body.add(ins.getText());
                }
            }
            f.body.add("}");
            pr.funcs.add(f);
        }
        pr.funcs.forEach(this::planFrame);

        StringBuilder sb = new StringBuilder();
        emitData(pr.dataItems, sb);
        emitText(pr.funcs, sb);
        return sb.toString();
    }

    /* ------------ parsing ------------ */
    private static class ParseResult {
        List<DataItem> dataItems = new ArrayList<>();
        List<Func> funcs = new ArrayList<>();
    }

    private ParseResult parse(List<String> lines) {
        ParseResult pr = new ParseResult();
        Iterator<String> it = lines.iterator();
        while (it.hasNext()) {
            String raw = it.next().trim();
            if (raw.isEmpty() || raw.startsWith(";")) continue;
            if (raw.startsWith("declare")) continue;
            if (raw.startsWith("@")) {
                pr.dataItems.add(parseData(raw));
                continue;
            }
            if (raw.startsWith("define")) {
                Func f = new Func();
                parseFuncHeader(raw, f);
                while (it.hasNext()) {
                    String ln = it.next();
                    f.body.add(ln);
                    if (ln.trim().equals("}")) break;
                }
                pr.funcs.add(f);
            }
        }
        return pr;
    }

    private void parseFuncHeader(String line, Func f) {
        // example: define dso_local i32 @main(i32 %a, i32 %b) {
        Matcher m = Pattern.compile("define\\s+\\w+\\s+(\\w+)\\s+@([\\w$\\.]+)\\((.*)\\)\\s*\\{").matcher(line);
        if (!m.find()) throw new RuntimeException("Bad function header: " + line);
        f.retType = m.group(1);
        f.name = m.group(2);
        String params = m.group(3).trim();
        if (!params.isEmpty()) {
            String[] ps = params.split(",");
            for (String p : ps) {
                p = p.trim();
                if (p.isEmpty()) continue;
                String[] seg = p.split("\\s+");
                String pname = seg[seg.length - 1];
                String ptype = seg[seg.length - 2];
                f.params.add(pname);
                f.paramWidths.add(typeWidth(ptype));
                f.valWidth.put(pname, typeWidth(ptype));
            }
        }
    }

    private int typeWidth(String typ) {
        if (typ == null) return 4;
        typ = typ.trim();
        if (typ.startsWith("i1") || typ.startsWith("i8")) return 1;
        return 4;
    }

    private DataItem parseData(String line) {
        DataItem di = new DataItem();
        int nameEnd = line.indexOf('=');
        di.name = line.substring(1, nameEnd).trim();
        if (line.contains("c\"")) { // string constant
            int start = line.indexOf("c\"") + 2;
            int end = line.lastIndexOf('"');
            String raw = line.substring(start, end);
            di.isString = true;
            di.str = decodeStr(raw);
        } else {
            di.isString = false;
            di.ints = parseInts(line);
        }
        return di;
    }

    private List<Integer> parseInts(String line) {
        List<Integer> ints = new ArrayList<>();
        int lbr = line.indexOf('[');
        int rbr = line.lastIndexOf(']');
        if (lbr >= 0 && rbr > lbr) {
            String inside = line.substring(lbr + 1, rbr);
            Matcher m = Pattern.compile("i\\d+\\s+(-?\\d+)").matcher(inside);
            while (m.find()) {
                ints.add(Integer.parseInt(m.group(1)));
            }
            // if empty, maybe zero-initialized array length known
            if (ints.isEmpty()) {
                Matcher lenM = Pattern.compile("\\[(\\d+)\\s+x").matcher(line);
                int len = lenM.find() ? Integer.parseInt(lenM.group(1)) : 0;
                for (int i = 0; i < len; i++) ints.add(0);
            }
        } else { // scalar
            Matcher m = Pattern.compile("(?:global|constant)\\s+i\\d+\\s+(-?\\d+)").matcher(line);
            if (m.find()) {
                ints.add(Integer.parseInt(m.group(1)));
            } else {
                ints.add(0);
            }
        }
        return ints;
    }

    private String decodeStr(String raw) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < raw.length(); i++) {
            char c = raw.charAt(i);
            if (c == '\\' && i + 2 < raw.length()) {
                char c1 = raw.charAt(i + 1);
                char c2 = raw.charAt(i + 2);
                if (isHex(c1) && isHex(c2)) {
                    int v = Integer.parseInt("" + c1 + c2, 16);
                    if (v == 0) { i += 2; continue; }
                    sb.append((char) v);
                    i += 2;
                } else {
                    sb.append(c1);
                    i++;
                }
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }

    private boolean isHex(char c) {
        return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
    }

    /* ------------ frame planning ------------ */
    private void planFrame(Func f) {
        int cursor = 0; // bytes used by locals/temps (excludes saved fp/ra)
        for (String p : f.params) {
            if (!f.valOffset.containsKey(p)) {
                cursor = allocValue(f, p, cursor);
            }
        }
        for (String raw : f.body) {
            String line = raw.trim();
            if (!line.startsWith("%")) continue;
            int eq = line.indexOf('=');
            if (eq < 0) continue;
            String dest = line.substring(0, eq).trim();
            String rest = line.substring(eq + 1).trim();
            captureWidth(f, dest, rest);
            if (rest.startsWith("alloca")) {
                int size = parseAllocaSize(rest);
                cursor = allocAlloca(f, dest, size, cursor);
            } else {
                if (!f.valOffset.containsKey(dest)) {
                    cursor = allocValue(f, dest, cursor);
                }
            }
        }
        f.frameSize = align4(cursor + 8); // saved fp/ra
    }

    private void captureWidth(Func f, String dest, String rest) {
        rest = rest.trim();
        if (rest.startsWith("load")) {
            Matcher m = Pattern.compile("load\\s+(\\S+)").matcher(rest);
            if (m.find()) f.valWidth.put(dest, typeWidth(m.group(1)));
        } else if (rest.startsWith("alloca")) {
            f.valWidth.put(dest, 4); // pointer
        } else if (rest.startsWith("icmp")) {
            f.valWidth.put(dest, 1);
        } else if (rest.startsWith("zext")) {
            f.valWidth.put(dest, 4);
        } else if (rest.startsWith("xor")) {
            f.valWidth.put(dest, rest.contains("xor i1") ? 1 : 4);
        } else if (rest.startsWith("getelementptr")) {
            f.valWidth.put(dest, 4);
        } else if (rest.startsWith("call")) {
            Matcher m = Pattern.compile("call\\s+(\\w+)\\s+@").matcher(rest);
            if (m.find()) f.valWidth.put(dest, typeWidth(m.group(1)));
        } else if (rest.startsWith("add") || rest.startsWith("sub") || rest.startsWith("mul")
                || rest.startsWith("sdiv") || rest.startsWith("srem")) {
            f.valWidth.put(dest, 4);
        }
    }

    private int allocAlloca(Func f, String name, int size, int cursor) {
        size = align4(size);
        int off = 8 + cursor + size; // address = fp - off
        f.allocaOffset.put(name, off);
        f.valWidth.put(name, 4); // pointer width
        return cursor + size;
    }

    private int allocValue(Func f, String name, int cursor) {
        int size = 4;
        int off = 8 + cursor + size;
        f.valOffset.put(name, off);
        f.valWidth.putIfAbsent(name, 4);
        return cursor + size;
    }

    private int parseAllocaSize(String rest) {
        // rest: "alloca i32, align 4" or "alloca [5 x i32], align 4"
        if (rest.contains("i32")) {
            Matcher m = Pattern.compile("alloca\\s+\\[(\\d+)\\s+x\\s+i32\\]").matcher(rest);
            if (m.find()) {
                int n = Integer.parseInt(m.group(1));
                return n * 4;
            }
            return 4;
        }
        if (rest.contains("i8") || rest.contains("i1")) {
            Matcher m = Pattern.compile("alloca\\s+\\[(\\d+)\\s+x\\s+i8\\]").matcher(rest);
            if (m.find()) {
                int n = Integer.parseInt(m.group(1));
                return n; // still align later
            }
            return 1;
        }
        return 4;
    }

    /* ------------ emission ------------ */
    private void emitData(List<DataItem> items, StringBuilder sb) {
        sb.append(".data\n");
        for (DataItem di : items) {
            if (di.isString) {
                sb.append(di.name).append(": .asciiz \"").append(escape(di.str)).append("\"\n");
            } else {
                sb.append(di.name).append(": .word ");
                for (int i = 0; i < di.ints.size(); i++) {
                    if (i > 0) sb.append(", ");
                    sb.append(di.ints.get(i));
                }
                sb.append("\n");
            }
        }
        sb.append(".text\n.globl main\n");
    }

    private String escape(String s) {
        return s.replace("\\", "\\\\").replace("\"", "\\\"").replace("\n", "\\n").replace("\t", "\\t");
    }

    private void emitText(List<Func> funcs, StringBuilder sb) {
        // main first to make entry point first instruction
        funcs.stream()
                .filter(f -> f.name.equals("main"))
                .forEach(f -> emitFunction(f, sb));
        funcs.stream()
                .filter(f -> !f.name.equals("main"))
                .forEach(f -> emitFunction(f, sb));
    }

    private void emitFunction(Func f, StringBuilder sb) {
        String fname = f.name;
        String exitLabel = fname + "_exit";
        sb.append(fname).append(":\n");
        // prologue
        sb.append("  addiu $sp, $sp, -").append(f.frameSize).append("\n");
        sb.append("  sw $ra, ").append(f.frameSize - 4).append("($sp)\n");
        sb.append("  sw $fp, ").append(f.frameSize - 8).append("($sp)\n");
        sb.append("  addiu $fp, $sp, ").append(f.frameSize).append("\n");
        // save params to slots
        for (int i = 0; i < f.params.size(); i++) {
            String p = f.params.get(i);
            Integer off = f.valOffset.get(p);
            if (off == null) continue;
            if (i < 4) {
                String reg = "$a" + i;
                sb.append("  sw ").append(reg).append(", -").append(off).append("($fp)\n");
            } else {
                int pos = (i - 4) * 4;
                sb.append("  lw $t0, ").append(pos).append("($fp)\n");
                sb.append("  sw $t0, -").append(off).append("($fp)\n");
            }
        }

        for (String raw : f.body) {
            String line = raw.trim();
            if (line.isEmpty() || line.equals("}")) continue;
            if (line.startsWith(";")) continue;
            if (line.endsWith(":")) {
                String label = line.substring(0, line.length() - 1);
                sb.append(fname).append("_").append(label).append(":\n");
                continue;
            }
            if (line.startsWith("store")) {
                emitStore(f, line, sb);
            } else if (line.contains(" = load")) {
                emitLoad(f, line, sb);
            } else if (line.contains(" = add")) {
                emitBinary(f, line, sb, "addu");
            } else if (line.contains(" = sub")) {
                emitBinary(f, line, sb, "subu");
            } else if (line.contains(" = mul")) {
                emitMul(f, line, sb);
            } else if (line.contains(" = sdiv")) {
                emitDivRem(f, line, sb, true);
            } else if (line.contains(" = srem")) {
                emitDivRem(f, line, sb, false);
            } else if (line.contains(" = icmp")) {
                emitIcmp(f, line, sb);
            } else if (line.contains(" = zext")) {
                emitZext(f, line, sb);
            } else if (line.contains(" = xor")) {
                emitXor(f, line, sb);
            } else if (line.contains(" = getelementptr")) {
                emitGep(f, line, sb);
            } else if (line.startsWith("br ")) {
                emitBr(f, line, sb);
            } else if (line.startsWith("ret")) {
                emitRet(f, line, sb, exitLabel);
            } else if (line.contains(" = call") || line.startsWith("call")) {
                emitCall(f, line, sb);
            } else {
                // ignore unsupported
            }
        }
        // epilogue
        sb.append(exitLabel).append(":\n");
        sb.append("  lw $ra, ").append(f.frameSize - 4).append("($sp)\n");
        sb.append("  lw $fp, ").append(f.frameSize - 8).append("($sp)\n");
        sb.append("  addiu $sp, $sp, ").append(f.frameSize).append("\n");
        if (fname.equals("main")) {
            sb.append("  li $v0, 10\n");
            sb.append("  syscall\n");
        } else {
            sb.append("  jr $ra\n");
        }
    }

    /* ------------ instruction emitters ------------ */
    private void emitStore(Func f, String line, StringBuilder sb) {
        // store i32 %v, i32* %ptr
        String[] parts = line.split("\\s+", 3);
        String rest = parts[2];
        String[] seg = rest.split(",", 2);
        String valPart = seg[0].trim(); // like "i32 %x"
        String ptrPart = seg[1].trim(); // like "i32* %y"
        String valOp = valPart.substring(valPart.indexOf(' ') + 1).trim();
        String ptrOp = ptrPart.substring(ptrPart.indexOf(' ') + 1).trim();
        boolean isByte = valPart.startsWith("i8") || valPart.startsWith("i1");

        sb.append("  # ").append(line.trim()).append("\n");
        String vReg = "$t0";
        loadOperand(f, valOp, vReg, sb);
        String aReg = "$t1";
        loadAddress(f, ptrOp, aReg, sb);
        if (isByte) {
            sb.append("  sb ").append(vReg).append(", 0(").append(aReg).append(")\n");
        } else {
            sb.append("  sw ").append(vReg).append(", 0(").append(aReg).append(")\n");
        }
    }

    private void emitLoad(Func f, String line, StringBuilder sb) {
        // %dest = load i32, i32* %ptr
        String dest = line.substring(0, line.indexOf('=')).trim();
        String rest = line.substring(line.indexOf("load") + 4).trim();
        String[] seg = rest.split(",");
        String typeTok = seg[0].trim();
        String ptrOp = seg[1].trim();
        ptrOp = ptrOp.substring(ptrOp.indexOf(' ') + 1).trim();
        boolean isByte = typeTok.startsWith("i8") || typeTok.startsWith("i1");

        sb.append("  # ").append(line.trim()).append("\n");
        String aReg = "$t1";
        loadAddress(f, ptrOp, aReg, sb);
        if (isByte) {
            sb.append("  lbu $t0, 0(").append(aReg).append(")\n");
        } else {
            sb.append("  lw $t0, 0(").append(aReg).append(")\n");
        }
        storeValue(f, dest, "$t0", sb, typeWidth(typeTok));
    }

    private void emitBinary(Func f, String line, StringBuilder sb, String op) {
        // %d = add i32 op1, op2
        String dest = line.substring(0, line.indexOf('=')).trim();
        String rest = line.substring(line.indexOf(op.contains("addu") ? "add" : "sub") + 3).trim();
        String[] seg = rest.split(",");
        String op1 = seg[0].trim();
        op1 = op1.substring(op1.indexOf(' ') + 1).trim();
        String op2 = seg[1].trim();
        op2 = op2.substring(op2.indexOf(' ') + 1).trim();

        sb.append("  # ").append(line.trim()).append("\n");
        loadOperand(f, op1, "$t0", sb);
        loadOperand(f, op2, "$t1", sb);
        sb.append("  ").append(op).append(" $t2, $t0, $t1\n");
        storeValue(f, dest, "$t2", sb);
    }

    private void emitMul(Func f, String line, StringBuilder sb) {
        String dest = line.substring(0, line.indexOf('=')).trim();
        String rest = line.substring(line.indexOf("mul") + 3).trim();
        String[] seg = rest.split(",");
        String op1 = seg[0].trim();
        op1 = op1.substring(op1.indexOf(' ') + 1).trim();
        String op2 = seg[1].trim();
        op2 = op2.substring(op2.indexOf(' ') + 1).trim();

        sb.append("  # ").append(line.trim()).append("\n");
        loadOperand(f, op1, "$t0", sb);
        loadOperand(f, op2, "$t1", sb);
        sb.append("  mul $t2, $t0, $t1\n");
        storeValue(f, dest, "$t2", sb);
    }

    private void emitDivRem(Func f, String line, StringBuilder sb, boolean isDiv) {
        String dest = line.substring(0, line.indexOf('=')).trim();
        String rest = line.substring(line.indexOf(isDiv ? "sdiv" : "srem") + 4).trim();
        String[] seg = rest.split(",");
        String op1 = seg[0].trim();
        op1 = op1.substring(op1.indexOf(' ') + 1).trim();
        String op2 = seg[1].trim();
        op2 = op2.substring(op2.indexOf(' ') + 1).trim();

        sb.append("  # ").append(line.trim()).append("\n");
        loadOperand(f, op1, "$t0", sb);
        loadOperand(f, op2, "$t1", sb);
        sb.append("  div $t0, $t1\n");
        sb.append(isDiv ? "  mflo $t2\n" : "  mfhi $t2\n");
        storeValue(f, dest, "$t2", sb);
    }

    private void emitIcmp(Func f, String line, StringBuilder sb) {
        // %d = icmp slt i32 %a, %b
        String dest = line.substring(0, line.indexOf('=')).trim();
        Matcher m = Pattern.compile("icmp\\s+(\\w+)\\s+i\\d+\\s+([^,]+),\\s+(.+)$").matcher(line);
        if (!m.find()) return;
        String cond = m.group(1);
        String lhs = m.group(2).trim();
        String rhs = m.group(3).trim();

        sb.append("  # ").append(line.trim()).append("\n");
        loadOperand(f, lhs.substring(lhs.indexOf(' ') + 1).trim(), "$t0", sb);
        loadOperand(f, rhs.substring(rhs.indexOf(' ') + 1).trim(), "$t1", sb);
        switch (cond) {
            case "slt":
                sb.append("  slt $t2, $t0, $t1\n");
                break;
            case "sgt":
                sb.append("  slt $t2, $t1, $t0\n");
                break;
            case "sle":
                sb.append("  slt $t2, $t1, $t0\n");
                sb.append("  xori $t2, $t2, 1\n");
                break;
            case "sge":
                sb.append("  slt $t2, $t0, $t1\n");
                sb.append("  xori $t2, $t2, 1\n");
                break;
            case "eq":
                sb.append("  xor $t2, $t0, $t1\n");
                sb.append("  sltiu $t2, $t2, 1\n");
                break;
            case "ne":
                sb.append("  xor $t2, $t0, $t1\n");
                sb.append("  sltu $t2, $zero, $t2\n");
                break;
            default:
                sb.append("  li $t2, 0\n");
        }
        f.valWidth.put(dest, 1);
        storeValue(f, dest, "$t2", sb, 1);
    }

    private void emitZext(Func f, String line, StringBuilder sb) {
        // %d = zext i1 %x to i32
        String dest = line.substring(0, line.indexOf('=')).trim();
        Matcher m = Pattern.compile("zext\\s+i\\d+\\s+([^\\s]+)\\s+to").matcher(line);
        if (!m.find()) return;
        String op = m.group(1);
        sb.append("  # ").append(line.trim()).append("\n");
        loadOperand(f, op, "$t0", sb);
        f.valWidth.put(dest, 4);
        storeValue(f, dest, "$t0", sb, 4);
    }

    private void emitXor(Func f, String line, StringBuilder sb) {
        // %d = xor i1 %a, true/false/%b
        String dest = line.substring(0, line.indexOf('=')).trim();
        Matcher m = Pattern.compile("xor\\s+i\\d+\\s+([^,]+),\\s+(.+)$").matcher(line);
        if (!m.find()) return;
        String op1 = m.group(1).trim();
        String op2 = m.group(2).trim();
        sb.append("  # ").append(line.trim()).append("\n");
        loadOperand(f, op1, "$t0", sb);
        loadOperand(f, op2, "$t1", sb);
        sb.append("  xor $t2, $t0, $t1\n");
        int w = line.contains("xor i1") ? 1 : 4;
        f.valWidth.put(dest, w);
        storeValue(f, dest, "$t2", sb, w);
    }

    private void emitGep(Func f, String line, StringBuilder sb) {
        // %d = getelementptr inbounds [N x i32], [N x i32]* %ptr, i32 idx0, i32 idx1
        String dest = line.substring(0, line.indexOf('=')).trim();
        String rest = line.substring(line.indexOf("getelementptr") + "getelementptr".length()).trim();
        rest = rest.replaceFirst("^inbounds\\s+", "");
        String[] parts = rest.split(",\\s*");
        if (parts.length < 2) return;
        String typePart = parts[0].trim();
        String ptrPart = parts[1].trim();
        String ptrOp = ptrPart.substring(ptrPart.indexOf('*') + 1).trim();

        int elemSize = typePart.contains("i8") ? 1 : 4;
        int arrLen = 1;
        Matcher lenM = Pattern.compile("\\[(\\d+)\\s+x").matcher(typePart);
        if (lenM.find()) arrLen = Integer.parseInt(lenM.group(1));

        // indices
        List<String> idxOps = new ArrayList<>();
        for (int i = 2; i < parts.length; i++) {
            String idxPart = parts[i];
            idxPart = idxPart.substring(idxPart.indexOf(' ') + 1).trim();
            idxOps.add(idxPart);
        }

        sb.append("  # ").append(line.trim()).append("\n");
        loadAddress(f, ptrOp, "$t0", sb); // base

        if (idxOps.isEmpty()) {
            // nothing
        } else if (idxOps.size() == 1) {
            String idx = idxOps.get(0);
            loadOperand(f, idx, "$t1", sb);
            if (elemSize == 4) sb.append("  sll $t1, $t1, 2\n");
            sb.append("  addu $t0, $t0, $t1\n");
        } else {
            // two indices
            String idx0 = idxOps.get(0);
            String idx1 = idxOps.get(1);
            loadOperand(f, idx0, "$t1", sb);
            loadOperand(f, idx1, "$t2", sb);
            int stride0 = arrLen * elemSize;
            if (stride0 == 4) {
                sb.append("  sll $t1, $t1, 2\n");
            } else if (stride0 != 0) {
                sb.append("  li $t3, ").append(stride0).append("\n");
                sb.append("  mul $t1, $t1, $t3\n");
            }
            if (elemSize == 4) sb.append("  sll $t2, $t2, 2\n");
            sb.append("  addu $t1, $t1, $t2\n");
            sb.append("  addu $t0, $t0, $t1\n");
        }
        storeValue(f, dest, "$t0", sb);
    }

    private void emitBr(Func f, String line, StringBuilder sb) {
        if (line.startsWith("br label")) {
            String target = line.substring(line.indexOf('%') + 1).trim();
            sb.append("  j ").append(labelOf(f, target)).append("\n");
        } else {
            Matcher m = Pattern.compile("br\\s+i1\\s+([^,]+),\\s+label\\s+%([^,]+),\\s+label\\s+%(.+)$").matcher(line);
            if (!m.find()) return;
            String cond = m.group(1).trim();
            String tLabel = m.group(2).trim();
            String fLabel = m.group(3).trim();
            sb.append("  # ").append(line.trim()).append("\n");
            loadOperand(f, cond, "$t0", sb);
            sb.append("  beq $t0, $zero, ").append(labelOf(f, fLabel)).append("\n");
            sb.append("  j ").append(labelOf(f, tLabel)).append("\n");
        }
    }

    private void emitRet(Func f, String line, StringBuilder sb, String exitLabel) {
        if (line.startsWith("ret void")) {
            sb.append("  j ").append(exitLabel).append("\n");
        } else {
            String val = line.substring(line.indexOf(' ') + 1).trim();
            val = val.substring(val.indexOf(' ') + 1).trim();
            loadOperand(f, val, "$v0", sb);
            sb.append("  j ").append(exitLabel).append("\n");
        }
    }

    private void emitCall(Func f, String line, StringBuilder sb) {
        // with or without dest
        String dest = null;
        String callPart = line;
        if (line.contains("=")) {
            dest = line.substring(0, line.indexOf('=')).trim();
            callPart = line.substring(line.indexOf("call"));
        }
        Matcher m = Pattern.compile("call\\s+(\\w+)\\s+@([\\w$\\.]+)\\((.*)\\)").matcher(callPart);
        if (!m.find()) return;
        String retType = m.group(1);
        String funcName = m.group(2);
        String argsStr = m.group(3).trim();
        List<String> args = new ArrayList<>();
        if (!argsStr.isEmpty()) {
            String[] seg = argsStr.split(",");
            for (String s : seg) {
                String op = s.trim();
                op = op.substring(op.indexOf(' ') + 1).trim();
                args.add(op);
            }
        }
        sb.append("  # ").append(line.trim()).append("\n");
        int extra = Math.max(0, args.size() - 4);
        if (extra > 0) {
            for (int i = args.size() - 1; i >= 4; i--) {
                loadOperand(f, args.get(i), "$t0", sb);
                sb.append("  addiu $sp, $sp, -4\n");
                sb.append("  sw $t0, 0($sp)\n");
            }
        }
        for (int i = 0; i < args.size() && i < 4; i++) {
            loadOperand(f, args.get(i), "$a" + i, sb);
        }

        switch (funcName) {
            case "getint":
                sb.append("  li $v0, 5\n  syscall\n");
                break;
            case "putint":
                sb.append("  move $a0, $a0\n"); // already in $a0
                sb.append("  li $v0, 1\n  syscall\n");
                break;
            case "putch":
                sb.append("  move $a0, $a0\n");
                sb.append("  li $v0, 11\n  syscall\n");
                break;
            case "putstr":
                sb.append("  move $a0, $a0\n");
                sb.append("  li $v0, 4\n  syscall\n");
                break;
            default:
                sb.append("  jal ").append(funcName).append("\n");
        }
        if (extra > 0) {
            sb.append("  addiu $sp, $sp, ").append(extra * 4).append("\n");
        }
        if (dest != null && !"void".equals(retType)) {
            int w = typeWidth(retType);
            f.valWidth.put(dest, w);
            storeValue(f, dest, "$v0", sb, w);
        }
    }

    /* ------------ helpers ------------ */
    private void loadOperand(Func f, String op, String reg, StringBuilder sb) {
        op = op.trim();
        int comma = op.indexOf(',');
        if (comma >= 0) op = op.substring(0, comma).trim();
        if (op.startsWith("%")) {
            Integer off = f.valOffset.get(op);
            if (off == null) off = f.allocaOffset.get(op);
            if (off == null) throw new RuntimeException("unknown operand " + op);
            int w = f.valWidth.getOrDefault(op, 4);
            if (w == 1) {
                sb.append("  lbu ").append(reg).append(", -").append(off).append("($fp)\n");
            } else {
                sb.append("  lw ").append(reg).append(", -").append(off).append("($fp)\n");
            }
        } else if (op.startsWith("@")) {
            sb.append("  la ").append(reg).append(", ").append(op.substring(1)).append("\n");
        } else if (op.equals("true")) {
            sb.append("  li ").append(reg).append(", 1\n");
        } else if (op.equals("false")) {
            sb.append("  li ").append(reg).append(", 0\n");
        } else {
            sb.append("  li ").append(reg).append(", ").append(Integer.parseInt(op)).append("\n");
        }
    }

    private void loadAddress(Func f, String op, String reg, StringBuilder sb) {
        op = op.trim();
        int comma = op.indexOf(',');
        if (comma >= 0) op = op.substring(0, comma).trim();
        if (op.startsWith("%") && f.allocaOffset.containsKey(op)) {
            int off = f.allocaOffset.get(op);
            sb.append("  addiu ").append(reg).append(", $fp, -").append(off).append("\n");
        } else if (op.startsWith("%")) {
            Integer off = f.valOffset.get(op);
            if (off == null) off = f.allocaOffset.get(op);
            if (off == null) throw new RuntimeException("unknown ptr " + op);
            sb.append("  lw ").append(reg).append(", -").append(off).append("($fp)\n");
        } else if (op.startsWith("@")) {
            sb.append("  la ").append(reg).append(", ").append(op.substring(1)).append("\n");
        } else {
            // immediate address
            sb.append("  li ").append(reg).append(", ").append(op).append("\n");
        }
    }

    private void storeValue(Func f, String name, String reg, StringBuilder sb) {
        storeValue(f, name, reg, sb, f.valWidth.getOrDefault(name, 4));
    }

    private void storeValue(Func f, String name, String reg, StringBuilder sb, int width) {
        Integer off = f.valOffset.get(name);
        if (off == null) off = f.allocaOffset.get(name);
        if (off == null) throw new RuntimeException("unknown dest " + name);
        if (width == 1) {
            sb.append("  sb ").append(reg).append(", -").append(off).append("($fp)\n");
        } else {
            sb.append("  sw ").append(reg).append(", -").append(off).append("($fp)\n");
        }
    }

    private String labelOf(Func f, String lbl) {
        return f.name + "_" + lbl;
    }

    private int align4(int v) {
        return (v + 3) / 4 * 4;
    }
}
